<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Pixel Art Converter VGA256</title>
  <style>
    body {
      background: #f7f7f7;
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 30px;
    }
    h1 {
      color: #333;
    }
    #outputCanvas {
      margin-top: 20px;
      border: 1px solid #333;
    }
    input[type="range"] {
      width: 250px;
      vertical-align: middle;
    }
    .controls {
      margin: 20px auto;
    }
  </style>
</head>
<body>
  <h1>Pixel Art Converter VGA256</h1>
  <div class="controls">
    <!-- Selettore file per immagini JPG o PNG -->
    <input type="file" id="imageInput" accept="image/png, image/jpeg"><br><br>
    
    <!-- Slider per definire la dimensione del "blocco" pixel -->
    <label for="pixelSize">Dimensione Pixel: </label>
    <input type="range" id="pixelSize" min="1" max="50" value="10">
    <span id="pixelSizeValue">10</span>
    <br><br>
    
    <!-- Checkbox per abilitare l'uso della palette personalizzata -->
    <label for="customPalette">Usa palette personalizzata</label>
    <input type="checkbox" id="customPalette">
    <br><br>
    
    <!-- Checkbox per abilitare il dithering (Floyd–Steinberg) -->
    <label for="dithering">Applica dithering (Floyd-Steinberg)</label>
    <input type="checkbox" id="dithering">
    <br><br>
    
    <!-- Slider per regolare il contrasto -->
    <label for="contrast">Contrasto (%): </label>
    <input type="range" id="contrast" min="50" max="150" value="100">
    <span id="contrastValue">100</span>
    <br><br>
    
    <!-- Bottone per scaricare l'immagine -->
    <button id="downloadBtn">Download Pixel Art</button>
  </div>
  
  <!-- Canvas per visualizzare la pixel art -->
  <canvas id="outputCanvas"></canvas>

  <script>
    // Variabile globale per salvare l'immagine corrente
    let currentImage = null;
    
    // Generazione della palette personalizzata (216 colori)
    const palette = [];
    const levels = [0, 51, 102, 153, 204, 255];
    for (let r of levels) {
      for (let g of levels) {
        for (let b of levels) {
          palette.push([r, g, b]);
        }
      }
    }

    // Funzione per cercare il colore della palette più vicino in base alla distanza euclidea
    function getNearestPaletteColor(r, g, b, palette) {
      let minDist = Infinity;
      let bestColor = [r, g, b];
      for (let i = 0; i < palette.length; i++) {
        let pr = palette[i][0], pg = palette[i][1], pb = palette[i][2];
        let dist = (r - pr) * (r - pr) + (g - pg) * (g - pg) + (b - pb) * (b - pb);
        if (dist < minDist) {
          minDist = dist;
          bestColor = palette[i];
        }
      }
      return bestColor;
    }

    // Funzione che limita un valore nell'intervallo [0,255]
    function clamp(value) {
      return Math.max(0, Math.min(255, value));
    }

    // Funzione per distribuire l'errore durante il dithering
    function distributeError(data, x, y, width, height, errR, errG, errB, factor) {
      if (x < 0 || x >= width || y < 0 || y >= height) return;
      let index = (y * width + x) * 4;
      data[index]   = clamp(data[index] + errR * factor);
      data[index+1] = clamp(data[index+1] + errG * factor);
      data[index+2] = clamp(data[index+2] + errB * factor);
    }

    // Funzione che applica il dithering Floyd-Steinberg (includendo contrasto e palette personalizzata)
    function applyDithering(imageData, contrastFactor, useCustomPalette, palette, width, height) {
      let data = imageData.data;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let idx = (y * width + x) * 4;
          let oldR = data[idx];
          let oldG = data[idx+1];
          let oldB = data[idx+2];
          // Applica il contrasto
          let rAdjusted = clamp((oldR - 128) * contrastFactor + 128);
          let gAdjusted = clamp((oldG - 128) * contrastFactor + 128);
          let bAdjusted = clamp((oldB - 128) * contrastFactor + 128);
          
          let newR, newG, newB;
          if (useCustomPalette) {
            [newR, newG, newB] = getNearestPaletteColor(rAdjusted, gAdjusted, bAdjusted, palette);
          } else {
            newR = Math.round(rAdjusted / 51) * 51;
            newG = Math.round(gAdjusted / 51) * 51;
            newB = Math.round(bAdjusted / 51) * 51;
          }
          data[idx]   = newR;
          data[idx+1] = newG;
          data[idx+2] = newB;
          
          let errR = rAdjusted - newR;
          let errG = gAdjusted - newG;
          let errB = bAdjusted - newB;
          distributeError(data, x+1, y, width, height, errR, errG, errB, 7/16);
          distributeError(data, x-1, y+1, width, height, errR, errG, errB, 3/16);
          distributeError(data, x, y+1, width, height, errR, errG, errB, 5/16);
          distributeError(data, x+1, y+1, width, height, errR, errG, errB, 1/16);
        }
      }
    }

    // Listener per l'input della dimensione del pixel: aggiorna il valore mostrato e rielabora se serve
    document.getElementById('pixelSize').addEventListener('input', function(e) {
      const pixelValue = e.target.value;
      document.getElementById('pixelSizeValue').innerText = pixelValue;
      if (currentImage) {
        convertToPixelArt(currentImage);
      }
    });

    // Listener per lo slider del contrasto
    document.getElementById('contrast').addEventListener('input', function(e) {
      document.getElementById('contrastValue').innerText = e.target.value;
      if (currentImage) {
        convertToPixelArt(currentImage);
      }
    });

    // Listener per la checkbox della palette personalizzata
    document.getElementById('customPalette').addEventListener('change', function(e) {
      if (currentImage) {
        convertToPixelArt(currentImage);
      }
    });

    // Listener per la checkbox del dithering
    document.getElementById('dithering').addEventListener('change', function(e) {
      if (currentImage) {
        convertToPixelArt(currentImage);
      }
    });

    // Listener per il download dell'immagine (scarica il canvas come PNG)
    document.getElementById('downloadBtn').addEventListener('click', function() {
      const canvas = document.getElementById('outputCanvas');
      const link = document.createElement('a');
      link.download = 'pixelart.png';
      link.href = canvas.toDataURL();
      link.click();
    });

    // Carica l'immagine selezionata dall'utente
    document.getElementById('imageInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        const img = new Image();
        img.onload = function() {
          currentImage = img;
          convertToPixelArt(img);
        }
        img.src = evt.target.result;
      }
      reader.readAsDataURL(file);
    });

    /**
     * Converte l'immagine in pixel art con effetto VGA256.
     * Procedura:
     * 1. Riduce l'immagine su un canvas offscreen a una risoluzione inferiore,
     *    in base al valore del cursore della dimensione del pixel.
     * 2. Applica:
     *    - Aggiustamento del contrasto;
     *    - Quantizzazione tramite palette personalizzata (se selezionata) oppure
     *      quantizzazione semplice (valori multipli di 51);
     *    - Opzionalmente il dithering (Floyd-Steinberg) con distribuzione dell'errore.
     * 3. Scala l'immagine processata sul canvas principale, mantenendo l'effetto pixelato.
     */
    function convertToPixelArt(img) {
      const pixelSize = parseInt(document.getElementById("pixelSize").value);
      const smallWidth = Math.max(1, Math.floor(img.width / pixelSize));
      const smallHeight = Math.max(1, Math.floor(img.height / pixelSize));

      // Canvas offscreen per riduzione risoluzione
      const offCanvas = document.createElement('canvas');
      offCanvas.width = smallWidth;
      offCanvas.height = smallHeight;
      const offCtx = offCanvas.getContext('2d');
      offCtx.imageSmoothingEnabled = false;
      offCtx.drawImage(img, 0, 0, smallWidth, smallHeight);

      let imageData = offCtx.getImageData(0, 0, smallWidth, smallHeight);
      let data = imageData.data;

      const contrastValue = parseInt(document.getElementById("contrast").value);
      const contrastFactor = contrastValue / 100;
      const useCustomPalette = document.getElementById("customPalette").checked;
      const applyDither = document.getElementById("dithering").checked;

      if (!applyDither) {
        // Senza dithering: per ogni pixel applico il contrasto e la quantizzazione
        for (let i = 0; i < data.length; i += 4) {
          let r = clamp((data[i] - 128) * contrastFactor + 128);
          let g = clamp((data[i+1] - 128) * contrastFactor + 128);
          let b = clamp((data[i+2] - 128) * contrastFactor + 128);
          if (useCustomPalette) {
            [r, g, b] = getNearestPaletteColor(r, g, b, palette);
          } else {
            r = Math.round(r / 51) * 51;
            g = Math.round(g / 51) * 51;
            b = Math.round(b / 51) * 51;
          }
          data[i]   = r;
          data[i+1] = g;
          data[i+2] = b;
        }
      } else {
        // Con dithering: applica l'algoritmo che distribuisce l'errore
        applyDithering(imageData, contrastFactor, useCustomPalette, palette, smallWidth, smallHeight);
      }

      // Riporta i dati processati sul canvas offscreen
      offCtx.putImageData(imageData, 0, 0);

      // Imposta il canvas di output e scalalo per mantenere l'effetto pixelato
      const outputCanvas = document.getElementById('outputCanvas');
      outputCanvas.width = smallWidth * pixelSize;
      outputCanvas.height = smallHeight * pixelSize;
      const outCtx = outputCanvas.getContext('2d');
      outCtx.imageSmoothingEnabled = false;
      outCtx.drawImage(offCanvas, 0, 0, outputCanvas.width, outputCanvas.height);
    }
  </script>
</body>
</html>
